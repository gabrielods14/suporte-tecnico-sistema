# Desenvolvimento do HelpWave Desktop

O desenvolvimento da versão desktop do HelpWave foi uma empreitada que buscou replicar toda a funcionalidade e experiência da versão web em uma aplicação desktop nativa, utilizando Python como linguagem base e CustomTkinter como framework de interface gráfica. A decisão por essa stack tecnológica partiu da necessidade de criar uma aplicação que mantivesse a mesma identidade visual e funcional do projeto web original, mas que pudesse ser executada de forma independente, sem depender de um navegador web.

A arquitetura da aplicação foi pensada de forma modular, seguindo os mesmos princípios de organização do projeto web. O ponto de entrada é o arquivo main.py, que contém a classe AppManager, responsável por gerenciar todo o ciclo de vida da aplicação. Essa classe funciona como um orquestrador central, controlando a transição entre diferentes telas e mantendo o estado global da aplicação, incluindo informações do usuário logado, página atual sendo exibida e identificadores de tickets selecionados. A inicialização da aplicação configura o CustomTkinter com um tema claro e cores azuis padrão, estabelecendo uma janela principal com dimensões de 1400 por 900 pixels, com um tamanho mínimo de 1200 por 700 pixels para garantir uma experiência adequada em diferentes resoluções de tela.

O fluxo de autenticação foi implementado de forma idêntica ao sistema web, garantindo compatibilidade total com o backend Flask que já estava em funcionamento. A página de login, encapsulada na classe LoginPage, apresenta uma interface moderna com um formulário centralizado sobre um fundo colorido, seguindo o mesmo design visual da versão web. O formulário inclui campos para usuário e senha, com a funcionalidade adicional de mostrar ou ocultar a senha através de um checkbox, além de opções para lembrar credenciais e recuperação de senha. A validação de entrada é feita tanto no lado do cliente quanto através da comunicação com o servidor, e todo o processo de login é executado em uma thread separada para evitar que a interface gráfica trave durante a comunicação com a API.

A comunicação com o backend é gerenciada pelo módulo api_client.py, que implementa um cliente HTTP completo com suporte para os métodos GET, POST, PUT e DELETE. Este módulo foi desenvolvido para ser uma tradução fiel do sistema de requisições da versão web, mantendo a mesma estrutura de headers, tratamento de erros e formato de dados. O sistema de autenticação utiliza tokens JWT que são salvos localmente em um arquivo no diretório home do usuário, permitindo que a sessão seja mantida entre diferentes execuções da aplicação. O cliente de API também implementa tratamento robusto de erros de conexão, timeout e problemas de rede, fornecendo mensagens de erro claras e específicas para cada situação, exatamente como ocorre na versão web.

Após o login bem-sucedido, o usuário é direcionado para a HomePage, que funciona como um dashboard central e ponto de navegação para todas as funcionalidades do sistema. Esta página implementa um layout em grid com uma barra lateral fixa, um cabeçalho superior e uma área de conteúdo principal que muda dinamicamente conforme a navegação. A barra lateral, implementada como um componente reutilizável chamado Sidebar, exibe o logo do HelpWave e um menu de navegação com ícones e textos descritivos para cada seção disponível. O cabeçalho, por sua vez, mostra informações do usuário logado e um menu dropdown com opções de perfil e logout, mantendo o usuário sempre ciente de seu estado de autenticação.

A página inicial do dashboard apresenta uma série de cards clicáveis que servem como atalhos para as diferentes funcionalidades do sistema. A visibilidade desses cards é controlada dinamicamente com base nas permissões do usuário logado, garantindo que apenas as funcionalidades apropriadas sejam exibidas. Usuários com permissão de cliente podem ver apenas o card para criar novos chamados, enquanto usuários de suporte têm acesso adicional aos cards de chamados em andamento, chamados concluídos e relatórios. Administradores, por sua vez, têm acesso completo, incluindo o card para cadastro de funcionários. Cada card possui efeitos visuais de hover que destacam a opção quando o mouse passa sobre ela, melhorando a experiência do usuário e fornecendo feedback visual imediato.

O sistema de navegação foi implementado de forma que a HomePage atua como um gerenciador de páginas, instanciando e destruindo diferentes componentes conforme necessário. Quando o usuário clica em um card ou item do menu lateral, a HomePage identifica qual página deve ser exibida e substitui o conteúdo atual pelo novo componente. Essa abordagem permite que apenas uma página seja mantida em memória por vez, otimizando o uso de recursos do sistema. As páginas disponíveis incluem a criação de novos tickets, visualização de tickets pendentes, visualização de tickets concluídos, detalhes de um ticket específico, cadastro de funcionários e geração de relatórios.

A página de criação de novos chamados implementa um formulário completo e validado, permitindo que os usuários preencham informações detalhadas sobre o problema que estão enfrentando. O formulário inclui campos para tipo de chamado, título, descrição detalhada, prioridade e anexos de arquivos. A validação é feita tanto no lado do cliente quanto no servidor, garantindo que todos os campos obrigatórios sejam preenchidos corretamente antes do envio. Uma funcionalidade interessante implementada nesta página é a integração com a API do Gemini AI, que permite gerar sugestões automáticas de resposta técnica baseadas no título e descrição do chamado. Essa funcionalidade ajuda os usuários a formular melhor suas solicitações e pode acelerar o processo de resolução de problemas.

As páginas de listagem de tickets, tanto para pendentes quanto para concluídos, implementam uma interface de tabela moderna que exibe informações resumidas de cada chamado. Cada linha da tabela mostra dados essenciais como identificador, título, status, prioridade e data de criação, permitindo que os usuários identifiquem rapidamente os chamados mais relevantes. A interface inclui funcionalidades de filtro e busca, embora essas possam variar na implementação específica. Ao clicar em um ticket da lista, o usuário é direcionado para a página de detalhes, que apresenta todas as informações completas do chamado, incluindo histórico de atualizações, comentários e possibilidade de edição para usuários com permissões adequadas.

A página de detalhes do ticket é uma das mais complexas do sistema, pois precisa exibir uma grande quantidade de informações de forma organizada e permitir interações como adicionar comentários, atualizar status e modificar informações. Esta página foi desenvolvida para ser responsiva e adaptável, utilizando frames scrolláveis quando necessário para acomodar conteúdo extenso. A interface permite que usuários de suporte e administradores atualizem o status dos chamados, adicionem observações técnicas e marquem tickets como resolvidos, enquanto usuários comuns podem acompanhar o progresso de seus chamados e adicionar informações complementares.

O sistema de componentes reutilizáveis foi uma parte fundamental da arquitetura, permitindo que elementos comuns fossem desenvolvidos uma vez e reutilizados em múltiplas páginas. Além da Sidebar e do Header já mencionados, o sistema inclui um componente de Toast para exibição de notificações, que pode mostrar mensagens de sucesso, erro, informação ou aviso com animações suaves. O componente de dropdown menu no cabeçalho permite acesso rápido a funcionalidades do perfil e logout, mantendo a interface limpa e organizada. Todos esses componentes seguem o mesmo padrão visual estabelecido no arquivo de configuração, garantindo consistência em toda a aplicação.

O arquivo config.py centraliza todas as configurações importantes da aplicação, incluindo URLs das APIs, paleta de cores, tamanhos de fonte e credenciais padrão para testes. A paleta de cores foi cuidadosamente escolhida para corresponder exatamente à versão web, utilizando tons de vermelho como cor primária, azul escuro como cor secundária e uma gama de cores neutras para backgrounds e textos. Essa centralização de configurações facilita a manutenção e permite que mudanças visuais ou de conectividade sejam feitas em um único local, afetando toda a aplicação de forma consistente.

O tratamento de erros foi implementado de forma abrangente em toda a aplicação, com diferentes níveis de tratamento dependendo do contexto. Erros de conexão com o servidor são capturados e exibidos com mensagens claras ao usuário, enquanto erros de validação são tratados diretamente nos formulários, destacando os campos problemáticos. O sistema também implementa tratamento de exceções genéricas para capturar qualquer erro inesperado, registrando informações detalhadas para depuração enquanto apresenta mensagens amigáveis ao usuário final.

A integração com o backend Flask foi feita de forma que a aplicação desktop utiliza exatamente as mesmas rotas e formatos de dados da versão web, garantindo que qualquer melhoria ou correção no backend beneficie ambas as versões simultaneamente. O cliente de API foi desenvolvido para ser compatível com diferentes cenários de erro HTTP, interpretando códigos de status e mensagens de erro do servidor para fornecer feedback apropriado ao usuário. A autenticação baseada em tokens JWT permite que a sessão seja mantida entre diferentes execuções da aplicação, melhorando a experiência do usuário ao evitar logins repetidos.

O desenvolvimento da interface gráfica priorizou a usabilidade e a acessibilidade, utilizando componentes do CustomTkinter que fornecem feedback visual adequado. Botões mudam de aparência quando o mouse passa sobre eles, campos de entrada destacam-se quando focados e mensagens de erro são exibidas de forma clara e não intrusiva. A tipografia foi escolhida para ser legível em diferentes tamanhos de tela, e o espaçamento entre elementos foi calculado para criar uma hierarquia visual clara que guia o olhar do usuário através da interface.

A estrutura de pastas do projeto foi organizada de forma lógica, separando componentes reutilizáveis, páginas específicas e utilitários em diretórios distintos. Essa organização facilita a manutenção e permite que novos desenvolvedores compreendam rapidamente a arquitetura do projeto. O uso de módulos Python permite que cada componente seja testado e desenvolvido de forma independente, enquanto a estrutura de imports garante que as dependências sejam claras e explícitas.

Um exemplo prático de como essa arquitetura modular funciona pode ser visto na implementação do sistema de login. Quando o usuário preenche as credenciais e clica no botão de entrar, o método handle_login da LoginPage é acionado, que por sua vez desabilita os campos de entrada e o botão para evitar múltiplos envios. O processo de autenticação é então executado em uma thread separada através do método _do_login, que utiliza o AuthService.login para fazer a requisição HTTP ao servidor. Se o login for bem-sucedido, o token é salvo através do api_client.save_auth_token, e o callback on_login_success é chamado, passando as informações do usuário para o AppManager, que então navega para a HomePage. Em caso de erro, uma mensagem apropriada é exibida através do componente Toast, e os campos são reabilitados para uma nova tentativa.

```python
def handle_login(self):
    """Processa o login"""
    if self.is_loading:
        return
    
    username = self.username_entry.get().strip()
    password = self.password_entry.get().strip()
    
    if not username or not password:
        show_toast(self, "Por favor, preencha usuário e senha", "error")
        return
    
    # Desabilita o botão e mostra loading
    self.is_loading = True
    self.login_button.configure(text="ENTRANDO...", state="disabled")
    self.username_entry.configure(state="disabled")
    self.password_entry.configure(state="disabled")
    
    # Faz login em thread separada para não travar a UI
    threading.Thread(target=self._do_login, args=(username, password), daemon=True).start()
```

O desenvolvimento do HelpWave Desktop representou um esforço significativo de tradução de uma aplicação web moderna para uma aplicação desktop nativa, mantendo toda a funcionalidade, design e experiência do usuário originais. A escolha por Python e CustomTkinter permitiu criar uma aplicação que se sente nativa no ambiente desktop enquanto mantém a flexibilidade e facilidade de desenvolvimento de tecnologias web. O resultado final é uma aplicação robusta, bem organizada e totalmente funcional que serve como uma alternativa viável à versão web, especialmente para usuários que preferem aplicações desktop ou trabalham em ambientes onde o acesso web pode ser limitado.



